---
layout: post
comments: true
title: 손에 잡히는 정규표현식
tags:
  - regex
  - 정규식
  - 독서
date: '2017-06-04 00:48'
---

서비스를 구축하다보면 이런저런 패턴들을 검사하고, 치환해야되는 경우가 많았다.  
뭐.. 정규식도 small language 느낌이라 검색을 해서 겸사겸사하면 당장은 쓸 수 있었다.  
하지만 사용에 있어 능숙하지 않았고, 때로는 검색 keyword 조차 모를 떄가 있어 책을 집어 들었다.


책은 회사에 있던 '손에 잡히는 정규표현식'이라는 책이다.  
선정 이유는 첫 번째로 가장 빠르게 접할 수 있었고(자리 옆 책꽂이에 있었따;;),  
두 번째 로는 160 페이지 가량으로 얇아서 금방 볼 수 있을 꺼 같아서 였다.  

자 이제 스스로의 정리를 위해 블로그로 남기려고 한다.  
시작해보자!  

## 목차

### 1장
뭔가 서론이라 패스


### 2~3장

#### 1. 마침표는 아무 문자(알파벳,숫자,문장부호 등) 하나와 일치한다.
Example (진한 부분이 매칭된 부분)
>***sale***s1.xls  
>orders3.xls  
>***sale***s2.xls  
>europe2.xls  
>정규식 .a..  

---

#### 2. 문자집합 [ ]
[]는 문자 집합을 의미하며, 여러 문자를 의미할 수 있다.  
때로는 한글자를 지칭하기 위해 사용되기도 한다. 이때는 가독성을 높이기 위해 일부러 넣기도한다.  
>E.g) http[s]?:// 와 https?://는 같은 역할을 하지만 []를 넣어서 가독성을 높일 수 있다.  

##### 1) 문자집합 범위 사용하기
-을 통해 범위를 표현할 수 있다.
>e.g. [0-9]와 [0123456789]는 동일하며, 하나의 숫자와 매칭된다.

주의할점) [A-z]는 언듯 보면 맞는 거 같지만, 중간에 대괄호([), 캐럿(^) 같은 ascii가 포함되어 있으므로, 지양하자.

##### 2) 제외하고 찾기
캐럿(^)를 쓰면 제외하고 찾을 수 있다.

>na1.xls  
>sa1.xls  
>***sam.xls***  
>정규식 [ns]a[^0-9]\\.xls  

---

### 4장 메타문자 사용하기
#### 1. 공백문자
> [\b]  역스페이스  
> \f    페이지 넘김(form feed)  
> \n    줄바꿈  
> \r    캐리지 리턴  
> \t    탭  
> \v    수직 탭  
> \s    모든 공백문자, [\f\n\r\t\v]  
> \s    공백문자가 아닌 모든 문자, [^\f\n\r\t\v]  


#### 2. 영숫자 문자
> \d    숫자 하나와 같음, [0-9]  
> \D    숫자를 제외한 문자 하나와 같음, [^0-9]  
> \w    대소문자와 밑줄을 포함하는 모든 영숫자, [a-zA-Z0-9_]  
> \W    영숫자나, 밑줄이 아닌 모든 문자, [^a-zA-Z0-9_]  


#### 3. 포직스 문자
> [:alnum:]   모든 영숫자, [a-zA-Z0-9]  
> [:alpha:]   모든 영문자, [a-zA-Z]  
> [:blank:]   빈칸이나 탭와 같다.  
> [:cntrl:]   아스키 제어문자(아스키 0번~31번, 127번)  
> [:digit:]   모든 한자리 숫자, [0-9]  
> [:print:]   출력 가능한 모든 문자  
> [:lower:]   모든 소문자, [a-z]  
> [:graph:]   [:print:]와 동일하나 빈칸(space)은 제외  
> [:punct:]   [:alnum:]이나 [:cntrl:]가 포함되지 않은 모든 문자  
> [:space:]   빈칸을 포함한 모든 공백 문자  
> [:upper:]   모든 대문자, [A-Z]  
> [:xdigit:]  몯ㄴ 16진수 숫, [a-fA-F0-9]  

---


### 5장 반복 찾기
#### 몇번인가?
> \+  한글자 이상 연속된 문자  
> \*  없거나 하나 이상 연속된 문자  
> ?   없거나 하나의 문자  

?는 문자 묶음에서 있는지 없는지 확실치 않은 특정문자 하나만 찾을떄 유용하다.
말이 좀 길어서 이상한데 예제를 보자.
> http[s]*  
위와 같이 쓰게 된다면 https://hello.com 이라는 문자열이라면 모두 매칭되어버린다.  
우리가 원하는게 https 를 찾는거 임에도 불구하고  
여기에 http[s]?를 쓰게 된다면 https만 매칭되게 된다.  

---

#### 범위 구간 찾기
반복 횟수를 지정할수 있으며, 최수, 최대또한 지정할 수 있다.

> ***4/8/03***  
> ***10-6-2004***  
> 2/2/2  
> ***01-01-01***  
> \d{1,2}[-\/]\d{1,2}[-\/]\d{2,4}  

---
#### 과하게 일치하는 상황 방지
책을 보면서 제일 재밋었던 부분인데,
간략히 설명하자면 이러하다.
```
living in <B>AK</B> and <B>HI</B>.
```
위와 같은 예문에서 B태그와 AK 부분을 찾고 싶다. 즉 and 앞의 B태그 부분이다.
```
<[Bb]>.*</[Bb]>
```
위와 같이 정규식을 짜게 되면, 아래의 두가지 케이스가 될 수 있다.
```
<B>AK</B>, <B>HI</B>, 짧게 짤라서 2개 인식
<B>AK</B> and <B>HI</B>, 길게 보고 1개로 인식
```
일반적인 경우 정규식은 아래쪽을 선택한다. 즉 한번에 매칭되는 갯수가 많은쪽을 선택하려 한다.
그래서 이를 greedy quantizer라고 한다.
하지만 우리는 2개를 인식하고 싶다면 어떻게 해야하는가? 이는 lazy quantizer라고 부른다.

```
<[Bb]>.*?</[Bb]>
```
위와 같이 ?를 넣게 되면 lazy하게 변하게 되면서 두개로 인식하게 된다.


---
다 적을려니 너무 많아서 끊어서 가겠다..
다음 장에서 이만..
